define(['ometa!sbvr-parser/SBVRLibs', 'underscore', 'has', 'ometa-core', 'inflection'], function(SBVRLibs, _, has) {
	//A parser for Semantics of Business Vocabulary and Rules (SBVR), an OMG standard.
	//Converts from Structured English (SBVR-SE) to Logical Formulation (SBVR-LF)
	//Specification: http://www.omg.org/spec/SBVR/1.0/
	
	var dataTypesInputHead,
		dataTypesVocabulary = "
			Vocabulary: " + SBVRLibs.TYPE_VOCAB + "
			Term:       Integer
			Term:       Real
			Term:       Text
			Term:       Date
			Term:       Date Time
			Term:       Time
			Term:       Interval
			Term:       File

			Term:       Serial
				Concept Type: Integer
				Note: An auto-incrementing 'Integer'.
			Term:       JSON
				Concept Type: Text
				Note: A 'Text' type that will only allow valid JSON.
			Term:       Hashed
				Concept Type: Text
				Note: A 'Text' type that will automatically be converted to a hash.

			Term:       Length
				Concept Type: Integer

			Fact type:  Text has Length
				Note: Length in characters
				Necessity: Each Text has exactly one Length

			Fact type:  Integer1 is greater than Integer2
				Synonymous Form: Integer2 is less than or equal to Integer1
			Fact type:  Integer1 is less than Integer2
				Synonymous Form: Integer2 is greater than or equal to Integer1
			Fact type:  Integer1 is equal to Integer2
				Synonymous Form: Integer2 is equal to Integer1
				Synonymous Form: Integer1 equals Integer2
				Synonymous Form: Integer2 equals Integer1

			Fact type:  Real1 is greater than Real2
				Synonymous Form: Real2 is less than or equal to Real1
			Fact type:  Real1 is less than Real2
				Synonymous Form: Real2 is greater or equal to than Real1
			Fact type:  Real1 is equal to Real2
				Synonymous Form: Real2 is equal to Real1
				Synonymous Form: Real1 equals Real2
				Synonymous Form: Real2 equals Real1


			Fact type:  Real is greater than Integer
				Synonymous Form: Integer is less than or equal to Real
			Fact type:  Integer is greater than Real
				Synonymous Form: Real is less than or equal to Integer

			Fact type:  Integer is less than Real
				Synonymous Form: Real is greater than or equal to Integer
			Fact type:  Real is less than Integer
				Synonymous Form: Integer is greater than or equal to Real

			Fact type:  Integer is equal to Real
				Synonymous Form: Real is equal to Integer
				Synonymous Form: Real equals Integer
				Synonymous Form: Integer equals Real


			Fact type:  Real1 is greater than Real2
				Synonymous Form: Real2 is less than or equal to Real1
			Fact type:  Real1 is less than Real2
				Synonymous Form: Real2 is greater or equal to than Real1
			Fact type:  Real1 is equal to Real2
				Synonymous Form: Real2 is equal to Real1
				Synonymous Form: Real1 equals Real2
				Synonymous Form: Real2 equals Real1

			Fact type:  Text1 is equal to Text2
				Synonymous Form: Text2 is equal to Text1
				Synonymous Form: Text1 equals Text2
				Synonymous Form: Text2 equals Text1

			Term:       Short Text
				Concept Type: Text
				--Necessity: each Short Text has a Length that is less than or equal to 255.

			Term:       Red Component
				Concept Type: Integer
			Term:       Green Component
				Concept Type: Integer
			Term:       Blue Component
				Concept Type: Integer
			Term:       Alpha Component
				Concept Type: Integer
			Term:       Color
				Concept Type: Integer
			Fact type:  Color has Red Component
				Necessity: Each Color has exactly one Red Component
			Fact type:  Color has Green Component
				Necessity: Each Color has exactly one Green Component
			Fact type:  Color has Blue Component
				Necessity: Each Color has exactly one Blue Component
			Fact type:  Color has Alpha Component
				Necessity: Each Color has exactly one Alpha Component"

	ometa SBVRParser <: SBVRLibs {
		EOL =
			(	'\n'
			|	'\r'
				'\n'?
			),
		EOLSpaces =
			{false}:eol
			(	EOL
				{true}:eol
			|	space
			)*
			?eol,
		Bind :identifier :bindings =
			// Check a var exists to bind to.
			{this.ruleVars[identifier]}:varNumber
			?(varNumber != null)
			{['RoleBinding', identifier, varNumber]}:binding
			(	?bindings
				{bindings.push(binding)}
			)?
			-> binding,

		spaces =
			(	~EOL
				space
			)*,

		Number =
			(	spaces <digit+>:n
				-> ['Number', parseInt(n, 10)]
			|	"one"
				-> ['Number', 1]
			),

		Real =
			spaces
			<	digit+
				'.'
				digit+
			>:n
			-> ['Real', Number(n)],

		Integer =
			spaces
			<digit+>:n
			-> ['Integer', Number(n)],
		Text =
			spaces
			'"'
			<	(	'\\' '"'
				|	~'"'
					anything
				)+
			>:text
			'"'
			-> ['Text', text],
		Value =
				Real
			|	Integer
			|	Text,
		
		toSBVREOL =
			spaces
			<	(	spaces
					(	InformalIdentifier
					|	'\'' InformalIdentifier '\''
					|	(	~space
							anything
						)+
					)
				)*
			>,
		toEOL =
			<	(	~EOL
					anything
				)*
			>,

		token :x =
			spaces seq(x):s
			&(	space
			|	end
			)
			-> s,

		AddIdentifier :identifierType :baseSynonym =
			&(IdentifierPart+):identifier
			{identifier.join(' ')}:identifier
			_AddIdentifier(identifierType, identifier, baseSynonym)
			apply(identifierType),
		
		InformalIdentifier =
			Identifier(undefined, true),
		Identifier :factTypeSoFar :noAutoComplete =
			~(<Term(factTypeSoFar)?>:term)?
			~(<Name(factTypeSoFar)?>:name)?
			(	?(term || name)
				(	?(term.length > name.length)
					Term(factTypeSoFar)
				|	Name(factTypeSoFar)
				)
			|	?(!noAutoComplete)
				(	Term(factTypeSoFar)
				|	Name(factTypeSoFar)
				)
			),
		Vocabulary =
			FindVocabulary:vocabulary
			-> ['Vocabulary', vocabulary],
		Name :factTypeSoFar =
			FindIdentifier('Name', factTypeSoFar),
		Term :factTypeSoFar =
			FindIdentifier('Term', factTypeSoFar):term
			(	<digit+>:n
				{term.push(['Number', Number(n)])}
			)?
			-> term,
		FindIdentifier :identifierType :factTypeSoFar =
			spaces
			'\''?:quote
			FindIdentifierNest(identifierType, factTypeSoFar):identifier
			(	?(!quote)
			|	seq(quote)
			)
			-> identifier,
		
		FindIdentifierNest :identifierType :factTypeSoFar :identifierSoFar =
			IdentifierPart:part
			(	?identifierSoFar
				-> (identifierSoFar + ' ' + part)
			|	-> part
			):identifierSoFar
			// Make sure the potential identifier so far is short enough to be valid.
			?(identifierSoFar.length <= this.longestIdentifier[identifierType])
			(	FindIdentifierNest(identifierType, factTypeSoFar, identifierSoFar)
			|	(	FindVocabulary(identifierSoFar)
				|	-> this.currentVocabulary
				):vocabulary
				IsFactTypeIdentifier(vocabulary, identifierType, factTypeSoFar, identifierSoFar):factTypeIdentifier
				?(factTypeIdentifier !== false)
				-> [identifierType, factTypeIdentifier, vocabulary]
			),
		
		FindVocabulary :identifier =
			spaces
			'('?:bracket
			FindVocabularyNest:vocabulary
			?(!identifier || this.vocabularies[vocabulary]['IdentifierChildren'].hasOwnProperty(identifier))
			(	?(!bracket)
			|	seq(')')
			)
			-> vocabulary,
		
		FindVocabularyNest :vocabularySoFar =
			IdentifierPart:part
			(	?vocabularySoFar
				-> (vocabularySoFar + ' ' + part)
			|	-> part
			):vocabularySoFar
			// Make sure the potential identifier so far is short enough to be valid.
			?(vocabularySoFar.length <= this.longestIdentifier['Vocabulary'])
			(	FindVocabularyNest(vocabularySoFar)
			|	?this.vocabularies.hasOwnProperty(vocabularySoFar)
				-> vocabularySoFar
			),

		IdentifierPart =
			spaces
			<	(	letter
				|	'-'
				)+
			>,
		
		
		addVerb =
			ClearSuggestions Verb(true),
		Verb :factTypeSoFar =
			FindVerb(factTypeSoFar),
		FindVerb :factTypeSoFar :verbSoFar :negated =
			(	?(factTypeSoFar && !verbSoFar)
				Keyword("isn't")
				{'is'}:verbSoFar
				{true}:negated
			)?
			VerbPart:part
			(	?verbSoFar
				-> (verbSoFar + ' ' + part)
			|	-> part
			):verbSoFar
			(	?(factTypeSoFar && verbSoFar == 'is')
				spaces
				Keyword('not')
				{true}:negated
			)?
			(	FindVerb(factTypeSoFar, verbSoFar, negated)
			|	(	?(factTypeSoFar===true)
				|	?this.isVerb(factTypeSoFar, verbSoFar)
				)
				{['Verb', this._verbForm(verbSoFar)]}:verb
				(	?negated
					{verb.push(true)}
				|	{verb.push(false)}
				)
				-> verb
			),
		VerbPart =
			spaces
			~Identifier
			IdentifierPart,
		
		JoiningQuantifier =
			matchForAll('Keyword',["and","at","most"]),
		
		// Be very careful with anywhere you use quantifier as any in-place modifications of the array will be remembered in memoisation.
		Quantifier =
			(	Keyword("each")
				-> ['UniversalQuantification']
			|	matchForAny('Keyword',["a","an","some"])
				-> ['ExistentialQuantification']
			|	matchForAll('Keyword',["at","most"]) Number:n
				-> ['AtMostNQuantification', ['MaximumCardinality', n]]
			|	matchForAll('Keyword',["at","least"]) Number:n
				(	JoiningQuantifier
					Number:m
					-> ['NumericalRangeQuantification', ['MinimumCardinality', n], ['MaximumCardinality', m]]
				|	-> ['AtLeastNQuantification', ['MinimumCardinality', n]]
				)
			|	matchForAll('Keyword',["more","than"]) Number:n {++n[1]}
				-> ['AtLeastNQuantification', ['MinimumCardinality', n]]
			|	Keyword("exactly") Number:n
				-> ['ExactQuantification', ['Cardinality', n]]
			|	Keyword("no")
				-> ['ExactQuantification', ['Cardinality', ['Number', 0]]]
			),

		Keyword :word :noToken =
			(	?(noToken===true) seq(word)
			|	?(noToken!==true) token(word)
			),
		
		addThat =
			Keyword("that"),
		addThe =
			Keyword("the"),
		addComma =
			Keyword(","),
		addOr =
			Keyword("or"),
		CreateVar :identifier =
			{this.ruleVars[identifier] = this.ruleVarsCount++}:varNumber
			-> ['Variable', ['Number', varNumber], identifier],
		EmbedVar :identifier :data =
			{this.ruleVars[identifier] = data},

		IsAtomicFormulation :factType :bindings =
			IsFactType(factType):realFactType
			?realFactType
			-> ['AtomicFormulation'].concat([['FactType'].concat(factType)], bindings),

		ClosedProjection :identifier :bind =
			addThat
			(	{[identifier]}:factType
				Verb(factType):verb {factType.push(verb)}
				(	RuleBody(factType, [bind])
				|	IsAtomicFormulation(factType, [bind])
				)
			|	RuleBody([], [], identifier, bind)
			),

		RuleBody :factType :bindings :parentIdentifier :parentBind =
			(	Quantifier:quant
				Term(factType):t
				CreateVar(t):tVar
				Bind(t, bindings):bind
				{factType.push(t)}
				(	ClosedProjection(t, bind):thatLF
					{tVar.push(thatLF)}
					addComma?
				)?
			|	addThe
				// TODO: Should be a "ReferencedTerm" or Name, rather than Identifier (which is Term or Name)
				Identifier(factType):identifier
				(	Bind(identifier, bindings)
				|	// Embed the var.
					// TODO: This should only happen for "Name"'s
					EmbedVar(identifier, identifier)
					Bind(identifier, bindings)
				)
				{factType.push(identifier)}
			|	// Embedded data
				Value:data
				// Is the type of embedded data allowed here?
				IsFactTypeIdentifier('Type', 'Term', factType, data[0]):factTypeIdentifier
				?(factTypeIdentifier !== false)
				{['Term', factTypeIdentifier, 'Type', data]}:identifier
				// Create the var so we can bind to it.
				EmbedVar(identifier, data)
				Bind(identifier, bindings):bind
				// Add the data to the binding
				{bind[2] = data}
				{factType.push(identifier)}
			)
			(	Verb(factType):v
				{factType.push(v)}
				{	if(parentIdentifier != null) {
						factType.push(parentIdentifier);
						bindings.push(parentBind);
					}
				}
				(	RuleBody(factType, bindings)
				|	IsAtomicFormulation(factType, bindings)
				)
			|	IsAtomicFormulation(factType, bindings)
			):lf
			-> (quant == null ? lf : quant.concat([tVar, lf])),

		Modifier =
			"It" "is" 
			(	"obligatory"
				-> ['ObligationFormulation']
			|	"necessary"	
				-> ['NecessityFormulation']
			|	"prohibited"
				-> ['ObligationFormulation', ['LogicalNegation']]
			|	"impossible"
				-> ['NecessityFormulation', ['LogicalNegation']]
			|	"not" "possible"
				-> ['NecessityFormulation', ['LogicalNegation']]
			|	"possible"
				-> ['PossibilityFormulation']
			|	"permitted"
				-> ['PermissibilityFormulation']
			):r
			"that"
			-> r,

		StartRule =
				"R:"
			|	"Rule:",
		NewRule =
			StartRule
			spaces
			&(toEOL):ruleText
			{this.ruleVarsCount = 0}
			Modifier:mod
			RuleBody([], []):ruleLF
			EOLTerminator
			{mod.length == 2 ? (mod[1][1] = ruleLF) : (mod[1] = ruleLF)}
			-> ['Rule', mod, ['StructuredEnglish', ruleText]],

		StartFactType =
				"F:"
			|	"Fact type:",
		NewFactType =
			StartFactType {[]}:factType
			(	Identifier:identifier
				addVerb:v
				{factType.push(identifier, v)}
			)+
			(	Identifier:identifier
				{factType.push(identifier)}
			)?
			AddFactType(factType, factType)
			{factType.push(['Attributes'])}
			-> ['FactType'].concat(factType),

		StartVocabulary =
			"Vocabulary:"
			-> 'Vocabulary',
		StartTerm =
			(	"T:"
			|	"Term:"
			)
			-> 'Term',
		StartName =
			(	"N:"
			|	"Name:"
			)
			-> 'Name',
		NewIdentifier =
			(	StartVocabulary
			|	StartTerm
			|	StartName
			):identifierType
			ClearSuggestions
			AddIdentifier(identifierType):identifier
			{identifier.push(['Attributes'])}
			-> identifier,
		NewAttribute =
			{this.lines[this.lines.length-1]}:currentLine
			AllowedAttrs(currentLine[0]):attrName
			{attrName.replace(/ /g, '')}:attrName
			spaces
			ApplyFirstExisting(['Attr' + attrName, 'DefaultAttr'], [currentLine]):attrVal
			-> {var lastLine = this.lines.pop(); lastLine[lastLine.length-1].push([attrName, attrVal]); lastLine},
							
		AllowedAttrs :termOrFactType =
			matchForAny('seq',this.branches.AllowedAttrs.call(this, termOrFactType)):attrName
			-> attrName.replace(':',''),
		DefaultAttr :currentLine =
			toSBVREOL,
		AttrConceptType :currentLine =
			{currentLine[1]}:identifierName
			{currentLine[2]}:identifierVocab
			{currentLine.slice(0, 3)}:identifier
			?(!this.vocabularies[identifierVocab]['ConceptTypes'].hasOwnProperty(identifier)) // Only allow one instance of Concept Type: attribute.
											 // TODO: Improve this to deal with synonyms and autocomplete/highlighting.
			// A concept type has to be a term (cannot be a name)
			Term:term
			(	?(currentLine[0] == 'FactType')
			|	{term[1]}:termName
				{term[2]}:termVocab
				?(identifierName != termName || identifierVocab != termVocab) // Do not allow a term to have itself as its concept type.
				{this.vocabularies[identifierVocab]['ConceptTypes'][identifier] = term}
				{this.vocabularies[termVocab]['IdentifierChildren'][termName].push([identifierName, identifierVocab])}
			)
			-> term,
		AttrDefinition :currentLine =
			(	addThe?
				// The following section is copied from RuleBody, should really be sorted properly.
				{this.ruleVarsCount = 0}
				Term:term
				CreateVar(term):tVar
				Bind(term):b
				ClosedProjection(term, b):thatLF
				{tVar.push(thatLF)}
				(	?(currentLine[0] == 'FactType')
				|	{this.vocabularies[currentLine[2]]['ConceptTypes'][currentLine.slice(0, 3)] = term}
					{this.vocabularies['IdentifierChildren'][term[1]].push([currentLine[1], currentLine[2]])}
				)?
				-> tVar
			|	Value:value
				(	addComma
					Value
				)*:values
				(	(	addComma?
						addOr
						Value
					)+:moreValues
				|	// The or is only required if we had comma-separated values.
					?(values.length == 0)
				)
				-> ['Enum', value.concat(values, moreValues)]
			),
		AttrGuidanceType :currentLine =
			matchForAny('seq', this.branches.AttrGuidanceType),
		AttrNecessity :currentLine =
			(	&(toEOL):ruleText
				RuleBody([], []):lf
				EOLTerminator
				-> ['Rule', ['NecessityFormulation', lf], ['StructuredEnglish', 'It is necessary that ' + ruleText]]
			|	toSBVREOL
			),
		AttrReferenceScheme :currentLine =
			(	Term:t
				EOLTerminator
				-> t
			|	toSBVREOL
			),
		AttrSynonym :currentLine =
			AddIdentifier(currentLine[0], currentLine[1]),
		AttrSynonymousForm :currentLine =
			{[]}:factType
			(	Identifier:identifier
				addVerb:v
				{factType.push(identifier, v)}
			)+
			(	Identifier:identifier
				{factType.push(identifier)}
			)?
			AddFactType(factType, currentLine.slice(1,-1))
			-> factType,
		AttrTermForm :currentLine =
			AddIdentifier('Term'):term
			{
				for(var i = 0; i < currentLine.length; i++) {
					if(currentLine[i][0] == 'Term') {
						var factType = [term, ['Verb', 'has', false], currentLine[i]];
						this.AddFactType(factType, factType);
					}
				}
			}
		-> term,

		StartComment =
			seq('--'),
		NewComment =
			StartComment
			toEOL,
		
		EOLTerminator =
			Terminator?
			spaces
			&(	EOL
			|	end
			),
		Terminator =
			spaces
			Keyword('.',true),
		Line =
			spaces
			(
				(	NewIdentifier
				|	NewFactType
				|	NewRule
				|	NewAttribute
				):l
				ClearSuggestions
				{this.lines.push(l)}
				-> l
			|	NewComment
			),
		Process =
			EOLSpaces?
			Line
			(	EOLSpaces
				Line
			)*
			space*
			end
			-> this.lines
	}

	SBVRParser.ClearSuggestions = function() {};
	/**
		Following are "instance" variables/functions rather than shared.
	*/
	SBVRParser.initialize = function() {
		this.tokensEnabled = false;
		this.reset();
	};
	
	SBVRParser._enableTokens = function() {
		this.tokensEnabled = true;
		SBVRLibs._enableTokens.call(this, ['StartVocabulary', 'StartTerm', 'StartName', 'StartFactType', 'StartRule', 'NewComment', 'Vocabulary', 'Term', 'Name', 'Modifier', 'Verb', 'Keyword', 'AllowedAttrs', 'AttrGuidanceType', 'Number', 'Value']);
	};
	SBVRParser._sideEffectingRules = [
		'Process',
		'Line',
		'NewIdentifier',
		'AddIdentifier',
		'NewFactType',
		'AddFactType',
		'NewAttribute',
		'AttrConceptType',
		'AttrDefinition',
		'AttrSynonym',
		'AttrSynonymousForm',
		'AttrTermForm'
	];
	
	SBVRParser._AddIdentifier = function(identifierType, identifier, baseSynonym) {
		if(baseSynonym == null) {
			baseSynonym = identifier;
		}
		if(identifierType == 'Vocabulary') {
			this.AddVocabulary(identifier, baseSynonym);
		}
		else {
			var vocabulary = this.vocabularies[this.currentVocabulary];
			// Make sure the identifier isn't taken, if it is then fail (for vocabs we allow switching back to that vocab by redeclaring).
			if(vocabulary['IdentifierChildren'].hasOwnProperty(identifier)) {
				this._pred(false);
			}
			if(baseSynonym == identifier) {
				vocabulary['IdentifierChildren'][baseSynonym] = [];
			}
			else {
				vocabulary['IdentifierChildren'][baseSynonym].push([identifier, this.currentVocabulary]);
			}
			vocabulary[identifierType][identifier] = baseSynonym;
		}
		// Check for longest identifier between current and pluralised form, as the plural form may well be (and often is) longer.
		this.longestIdentifier[identifierType] = Math.max(identifier.length, identifier.pluralize().length, this.longestIdentifier[identifierType]);
	};
	
	// Returns the base synonym for this identifier.
	SBVRParser.BaseSynonym = function(vocabulary, identifierType, identifier) {
		var identifiers = this.vocabularies[vocabulary][identifierType];
		if(identifiers.hasOwnProperty(identifier)) {
			return identifiers[identifier];
		}
		identifier = identifier.singularize();
		if(identifiers.hasOwnProperty(identifier)) {
			return identifiers[identifier];
		}
		return false;
	};

	// Checks that the identifier is valid in this point of the fact type and returns the identifier as it is found in the fact type.
	SBVRParser.IsFactTypeIdentifier = function(vocabulary, identifierType, factTypeSoFar, identifier) {
		identifier = this.BaseSynonym(vocabulary, identifierType, identifier);
		if(identifier === false) {
			return false;
		}
		var identifiers = this.branches[identifierType].call(this, factTypeSoFar, vocabulary);
		if(identifiers.indexOf(identifier) !== -1) {
			return identifier;
		}
		return false;
	};

	SBVRParser.isVerb = function(factTypeSoFar, verb) {
		verb = ['Verb',this._verbForm(verb)];
		var currentLevel = this._traverseFactType(factTypeSoFar);
		if(currentLevel===false) {
			// We have no fact type matching this chain.
			return false;
		}
		if(currentLevel.hasOwnProperty(verb)) {
			// We found the verb.
			return true;
		}
		if(currentLevel.hasOwnProperty('__valid')) {
			// We have a valid fact type up to here, try a new one.
			// TODO: Should this actually be looking if the verb before last term is valid?
			return this.isVerb([], verb);
		}
		return false;
	};

	SBVRParser._verbForm = function(verb) {
		// People are eating.. Person is eating
		// Not: Police arest people.. Police isst people
		// I used a mispelling here because I could not find a case with a correct word, however in case I just missed one I'd rather check for the space.
		// People aren't animals.. Person isn't animal. Should probably be allowed, however what are our thoughts on contractions?
		if(verb.slice(0,4) == 'are ') {
			return 'is ' + verb.slice(4);
		}
		// Students are people.. Student is person
		if(verb == 'are') {
			return 'is';
		}
		// People have eyes.. Person has eyes
		if(verb=='have') {
			return 'has';
		}
		return verb;
	};

	SBVRParser.IsFactType = function(factType) {
		var currentLevel = this._traverseFactType(factType);
		if(currentLevel === false) {
			return false;
		}
		return currentLevel.__valid;
	};

	var removeRegex = new RegExp('^(?:' + 
									[	['Term',''].toString(),
										['Name',''].toString(),
										['Verb',''].toString()
									].join('|') +
								')(.*?)(?:,(.*))?$'),
		allowedAttrLists = [
			'Concept Type:',
			'Definition:',
			'Definition (Informal):',
			'Description:',
			'Dictionary Basis:',
			'Example:',
			'General Concept:',
			'Namespace URI:',
			'Necessity:',
			'Note:',
			'Possibility:',
			'Reference Scheme:',
			'See:',
			'Source:',
			'Subject Field:'
		];
	if (has('SBVR_EXTENSIONS')) {
		allowedAttrLists = [
			/* Custom Attributes */
			'Database ID Field:',
			'Database Table Name:'
			/* End Custom */
		].concat(allowedAttrLists);
	}
	allowedAttrLists = {
		Term: [
			'Synonym:'
		].concat(allowedAttrLists),
		Name: [
			'Synonym:'
		].concat(allowedAttrLists),
		FactType: [
			'Synonymous Form:',
			'Term Form:'
		].concat(allowedAttrLists),
		Rule: [
			'Rule Name:',
			'Guidance Type:',
			'Source:',
			'Synonymous Statement:',
			'Note:',
			'Example:',
			'Enforcement Level:'
		]
	};
	function getValidFactTypeParts(vocabulary, identifierType, factTypeSoFar) {
		var vocabularies = this.vocabularies;
		if(factTypeSoFar == null || factTypeSoFar.length == 0) {
			var identifiers;
			if(vocabulary == null) {
				identifiers = vocabularies[this.currentVocabulary][identifierType];
				// identifiers = {};
				// for(vocabulary in vocabularies) {
					// if(vocabularies.hasOwnProperty(vocabulary)) {
						// _.extend(identifiers, vocabularies[vocabulary][identifierType]);
					// }
				// }
			}
			else {
				identifiers = vocabularies[vocabulary][identifierType];
			}
			return _.keys(identifiers);
		}
		var factTypePart,
			currentLevel = this._traverseFactType(factTypeSoFar),
			factTypeParts = {},
			followChildrenChain = function(vocabulary, identifier) {
				vocabulary = vocabularies[vocabulary];
				var identifiers = vocabulary[identifierType];
				if(identifiers.hasOwnProperty(identifier)) {
					factTypeParts[identifiers[identifier]] = true;
				}
				for(var i = 0; i < vocabulary['IdentifierChildren'][identifier].length; i++) {
					var child = vocabulary['IdentifierChildren'][identifier][i];
					followChildrenChain(child[1], child[0]);
				}
			};
		for(factTypePart in currentLevel) {
			if(currentLevel.hasOwnProperty(factTypePart)) {
				var matches = removeRegex.exec(factTypePart);
				var factTypePartVocabulary;
				if(matches != null) {
					factTypePart = matches[1];
					if(matches[2]) {
						factTypePartVocabulary = matches[2];
						followChildrenChain(factTypePartVocabulary, factTypePart);
					}
					else {
						factTypeParts[factTypePart] = true;
					}
				}
			}
		}
		return _.keys(factTypeParts);
	}
	SBVRParser.reset = function() {
		SBVRLibs.initialize.call(this);
		this.branches = {
			ClearSuggestions: [], //This stops us suggesting any autocomplete before this point.
			StartVocabulary: ['Vocabulary:'],
			StartTerm: ['Term:      '],
			StartName: ['Name:      '],
			StartFactType: ['Fact type: '],
			StartRule: ['Rule:      '],
			Vocabulary: function(factTypeSoFar) {
				return _.keys(this.vocabularies);
			},
			Term: function(factTypeSoFar, vocabulary) {
				return getValidFactTypeParts.call(this, vocabulary, 'Term', factTypeSoFar);
			},
			Name: function(factTypeSoFar, vocabulary) {
				return getValidFactTypeParts.call(this, vocabulary, 'Name', factTypeSoFar);
			},
			Verb: function(factTypeSoFar, vocabulary) {
				return getValidFactTypeParts.call(this, vocabulary, 'Verb', factTypeSoFar);
			},
			AllowedAttrs: function(termOrFactType) {
				if(allowedAttrLists.hasOwnProperty(termOrFactType)) {
					return allowedAttrLists[termOrFactType];
				}
				else if(termOrFactType == null) {
					return allowedAttrLists.Term.concat(allowedAttrLists.Name, allowedAttrLists.FactType);
				}
				return [];
			},
			AttrGuidanceType: [
				'operative business rule',
				'structural business rule',
				'advice of permission',
				'advice of possibility',
				'advice of optionality',
				'advice of contingency'
			],
			Modifier: [
				'It is obligatory that',
				'It is necessary that',
				'It is prohibited that',
				'It is impossible that',
				'It is not possible that',
				'It is possible that',
				'It is permitted that'
			],
			Quantifier: [
				'each',
				'a',
				'an',
				'some',
				'at most',
				'at least',
	//			'and at most',
				'more than',
				'exactly',
				'no'
			],
			JoiningQuantifier: ['and at most'],
			Number: [
				'1', '2', '3', '4', '5', '6', '7', '8', '9',
				'one'
			],
			addThat: ['that', 'that the'],
			addThe: ['the'],
			addComma: [','],
			addOr: ['or'],
			Terminator: ['.']
		};
		this.longestIdentifier = {
			'Vocabulary': 0,
			'Term': 0,
			'Name': 0
		};
		this.ruleVars = {};
		this.ruleVarsCount = 0;
		this.lines = ['Model'];
		
		// Process the datatypes vocabulary,
		// this will not make use of reusing memoisations,
		// however it will not break them for standard use as it leaves this.inputHead as it finds it.
		var origInputHead = this.inputHead;
		this.inputHead = dataTypesInputHead;
		this.matchAll(dataTypesVocabulary, 'Process');
		dataTypesInputHead = this.inputHead;
		// And then switch to the "Default" vocabulary for normal parsing.
		this.matchAll('Vocabulary: Default', 'Process');
		this.inputHead = origInputHead;
	};


	/** **/
	SBVRParser.matchForAny = function(rule, arr) {
		var self = this,
        origInput = this.input,
        ref = {},
        result = ref;
		
		for (var idx = 0; idx < arr.length; idx++) {
			try {
				self.input = origInput;
				result = self._applyWithArgs.call(self, rule, arr[idx]);
			}
			catch (e) {
				if (!(e instanceof SyntaxError)) {
					throw e;
				}
			}

			if (result !== ref) {
				return result;
			}
		}
		throw this._fail();
	};
	SBVRParser.matchForAll = function(rule, arr) {
		for (var idx = 0; idx < arr.length; idx++) {
			this._applyWithArgs.call(this, rule, arr[idx]);
		}
	};
	//TODO: This is a bit of a hack for case insensitivity, a better solution needs to be implemented in future.
	SBVRParser.exactly = function(wanted) {
		if (wanted.toLowerCase() === this._apply("lowerCaseAnything")) {
			return wanted;
		}
		throw this._fail();
	};
	// This is a bit hacky, but the lack of arguments means the .toLowerCase() is memoised,
	// saving a lot of .toLowerCase() calls in "exactly" (which isn't memoised :( )
	SBVRParser.lowerCaseAnything = function() {
		return this._apply("anything").toLowerCase();
	};
	
	// For performance we can use this.
	SBVRParser._disablePrependingInput();
	
	return SBVRParser;

});
