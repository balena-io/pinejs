define(['sbvr-parser/sbvr-libs'], function(SBVRLibs) {
	SBVRLibs = SBVRLibs.SBVRLibs;
	// TODO: Make the LFValidator validate that it is actually correctly structured LF.
	ometa LFValidator <: SBVRLibs {
		trans
			[:t apply(t):a]
			-> a,
		token :x =
			[:t ?{t==x} apply(x):a]
			-> a,

		letters =
			letter+:l space*
			-> l.join(''),

		Number
			number:n ?{!isNaN(n)}
			-> ['Number', parseInt(n, 10)],

		Model
			{[]}:xs
			(
				(	"Vocabulary"
				|	"Term"
				|	"Name"
				|	"FactType"
				|	"Rule"
				):x
				(	?(x != null)
					{xs.push(x)}
				)?
			)*
			-> ['Model'].concat(xs),

		FactType
			{[]}:factType
			(	(	"Term"
				|	"Name"
				):identifier
				"Verb":verb
				{factType.concat([identifier, verb])}:factType
			)*
			(	(	"Term"
				|	"Name"
				):identifier
				{factType.push(identifier)}
			)?
			&(:attrs AddFactType(factType, factType))?
			addAttributes(['FactType'].concat(factType)),

		Vocabulary
			:vocab
			AddVocabulary(vocab, vocab)
			addAttributes(['Vocabulary', vocab]),

		Term
			:term
			:vocab
			(	(	// Variable number
					"Number"
				|	// Or embedded data
					Value
				):data
				-> ['Term', term, vocab, data]
			|	addAttributes(['Term', term, vocab])
			),
		Name
			:name
			:vocab
			addAttributes(['Name', name, vocab]),
		Verb
			:v
			(	true
			|	false
			):negated
			-> ['Verb', v, negated],
		Rule
			(	"ObligationFormulation"
			|	"NecessityFormulation"
			|	"PossibilityFormulation"
			|	"PermissibilityFormulation"
			):x
			"StructuredEnglish":t
			-> ['Rule', x, t],
		addAttributes :termOrFactType =
			(	end
			|	{{}}:attrsFound
				{['Attributes']}:attrs
				[	'Attributes'
					[	:attrName
						ApplyFirstExisting(['Attr' + attrName, 'DefaultAttr'], [termOrFactType]):attrVal
						(	?(attrVal != null)
							{attrsFound[attrName] = attrVal}
							{attrs.push([attrName, attrVal])}
						)?
					]*
					end
				]
				defaultAttributes(termOrFactType, attrsFound, attrs)
			)
			-> termOrFactType,
		DefaultAttr :tableID =
			anything,
		AttrConceptType :termOrFactType =
			[	'Term' 
				:conceptType
				:vocab
			]:term
			{this.vocabularies[this.currentVocabulary]['ConceptTypes'][termOrFactType] = term}
			-> term,
		AttrDefinition :termOrFactType =
			(	['Enum' anything+:values]
			|	trans
			),
		AttrNecessity :termOrFactType =
				"Rule"
			|	DefaultAttr,
		AttrSynonymousForm :factType =
			:synForm
			AddFactType(synForm, factType.slice(1))
			-> synForm,

		StructuredEnglish
			:a
			-> ['StructuredEnglish', a],
		
		ObligationFormulation
			trans*:xs
			-> ['ObligationFormulation'].concat(xs),
		NecessityFormulation
			trans*:xs
			-> ['NecessityFormulation'].concat(xs),
		PossibilityFormulation
			trans*:xs
			-> ['PossibilityFormulation'].concat(xs),
		PermissibilityFormulation
			trans*:xs
			-> ['PermissibilityFormulation'].concat(xs),

		LogicalNegation
			trans:xs
			-> ['LogicalNegation'].concat([xs]),

		quant =
			(	"UniversalQuantification"
			|	"ExistentialQuantification"
			|	"ExactQuantification"
			|	"AtMostNQuantification"
			|	"AtLeastNQuantification"
			|	"NumericalRangeQuantification"
			),
		UniversalQuantification
			"Variable":v trans*:xs
			-> ['UniversalQuantification', v].concat(xs),
		ExistentialQuantification
			"Variable":v trans*:xs
			-> ['ExistentialQuantification', v].concat(xs),
		ExactQuantification
			"Cardinality":i
			"Variable":v trans*:xs
			-> ['ExactQuantification', i, v].concat(xs),
		AtMostNQuantification
			"MaximumCardinality":a
			"Variable":v trans*:xs
			-> ['AtMostNQuantification', a, v].concat(xs),
		AtLeastNQuantification
			"MinimumCardinality":i
			"Variable":v trans*:xs
			-> ['AtLeastNQuantification', i, v].concat(xs),
		NumericalRangeQuantification
			"MinimumCardinality":i "MaximumCardinality":a
			"Variable":v trans*:xs
			-> ['NumericalRangeQuantification', i, a, v].concat(xs),

		Cardinality
			"Number":n
			-> ['Cardinality', n],
		MinimumCardinality
			"Number":n
			-> ['MinimumCardinality', n],
		MaximumCardinality
			"Number":n
			-> ['MaximumCardinality', n],

		Variable
			"Number":num
			"Term":term
			(	"AtomicFormulation"
			|	quant
			)*:w
			-> ['Variable', num, term].concat(w),

		Real
			number:num
			?{!isNaN(num)}
			-> ['Real', num],

		Integer
			number:num
			?{!isNaN(num)}
			-> ['Integer', num],

		Text
			anything:text
			-> ['Text', text],

		Value =
				"Real"
			|	"Integer"
			|	"Text",

		RoleBinding
			(	"Term"
			|	"Name"
			):identifier
			(	number
			|	Value
			):bindIdentifier
			-> ['RoleBinding', identifier, bindIdentifier], 
		AtomicFormulation
			"FactType":f
			"RoleBinding"*:b
			-> ['AtomicFormulation', f].concat(b)
	}
	
	LFValidator.initialize = function() {
		SBVRLibs.initialize.call(this);
	};

	LFValidator.defaultAttributes = function(termOrVerb, attrsFound, attrs) {
		termOrVerb.push(attrs);
	};
	
	return LFValidator;
});
