define(['lodash', 'sbvr-parser/sbvr-libs'], function(_, SBVRLibs) {
	SBVRLibs = SBVRLibs.SBVRLibs;

	ometa SBVRCompilerLibs <: SBVRLibs {}

	SBVRCompilerLibs.initialize = function() {
		SBVRLibs.initialize.call(this);
	};

	SBVRCompilerLibs.TYPE_VOCAB = 'Type';

	SBVRCompilerLibs.IsPrimitive = function(term) {
		// do {
			if (term[2] == this.TYPE_VOCAB) {
				return term[1];
			}
		// } while (this.conceptTypes.hasOwnProperty(termName) && (termName = this.conceptTypes[termName]));
		if( (term = this.FollowConceptType(term)) !== false ) {
			if (term[2] == this.TYPE_VOCAB) {
				return term[1];
			}
		}
		return false;
	};

	SBVRCompilerLibs.IsChild = function(child, parent) {
		// Parent should be in the form ['Term', ...], where we care about the ... bit.
		do {
			if(this.IdentifiersEqual(child, parent)) {
				return true;
			}
		} while( (child = this.FollowConceptType(child)) !== false );
		return false;
	};

	SBVRCompilerLibs.MappedFactType = function(factType) {
		var traverseInfo = this._traverseFactType(factType),
			mappedFactType = [];
		if(traverseInfo===false || !traverseInfo.hasOwnProperty('__valid')) {
			return false;
		}
		for(var i = 0; i < traverseInfo.__valid.length; i++) {
			mappedFactType[i] = traverseInfo.__valid[i].slice();
		}
		// Keep the negated status the same as fact type passed in.
		mappedFactType[1][2] = factType[1][2];
		return mappedFactType;
	};

	SBVRCompilerLibs.UnmappedFactType = function(factType) {
		var mappedFactType = this.MappedFactType(factType);
		if(mappedFactType === false) {
			return false;
		}
		for(var i = 0; i < mappedFactType.length; i++) {
			mappedFactType[i] = mappedFactType[i].slice(0, 3);
		}
		return mappedFactType;
	};

	SBVRCompilerLibs.GetResourceName = function(termOrFactType) {
		var i = 0, resource = [];
		if(_.isString(termOrFactType)) {
			return termOrFactType.replace(new RegExp(' ', 'g'), '_');
		}
		else {
			for(;i < termOrFactType.length; i++) {
				resource.push(termOrFactType[i][1].replace(new RegExp(' ', 'g'), '_'));
			}
			return resource.join('-');
		}
	};

	SBVRCompilerLibs.GetTable = function(termNameOrFactType) {
		return this.tables[this.GetResourceName(termNameOrFactType)];
	};

	SBVRCompilerLibs.GetTableID = function(termOrFactType) {
		switch(termOrFactType[0]) {
			case 'Term':
			case 'Name':
				return termOrFactType[1];
			default:
				return termOrFactType;
		}
	};

	SBVRCompilerLibs.GetTableField = function(table, fieldName) {
		var fieldID = this.GetTableFieldID(table, fieldName);
		if(fieldID === false) {
			return false;
		}
		return table.fields[fieldID];
	};

	SBVRCompilerLibs.GetTableFieldID = function(table, fieldName) {
		var tableFields = table.fields;
		for(var i = 0; i < tableFields.length; i++) {
			if(tableFields[i].fieldName == fieldName) {
				return i;
			}
		}
		return false;
	};

	// ometaifyObject = function(variable) {
		// if(_.isArray(variable)) {
			// for(var i=0;i<variable.length;i++) {
				// variable[i] = ometaifyObject(variable[i]);
			// }
			// return variable;
		// }
		// if (typeof variable === 'object') {
			// var ometaArray = [];
			// for(var key in variable) {
				// if(variable.hasOwnProperty(key)) {
					// ometaArray.push([key, ometaifyObject(variable[key])]);
				// }
			// }
			// return ometaArray;
		// }
		// return variable;
	// }

	return SBVRCompilerLibs;
});